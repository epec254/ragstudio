

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en-US" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en-US"> <!--<![endif]-->

<head>
  <!-- cookie consent -->
  
    <!-- Combined Onetrust and Rudderstack Implementation Scripts -->
    <!-- Onetrust Initialization -->
    <script type="text/javascript" src="https://cdn.cookielaw.org/consent/92466579-1717-44d3-809d-a05fb02843ed-test/OtAutoBlock.js"></script>
    <script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="92466579-1717-44d3-809d-a05fb02843ed-test"></script>
    <link rel="stylesheet" id="db-onetrust-style" href="https://www.databricks.com/wp-content/uploads/db_onetrust.css" media="all" />
    <!-- Setting Rudderstack Write Key -->
    <script>window.rudderstackKey = "2SOR9fvSr5Fi6tN2ihPbVHnX1SZ" </script>
    <!-- Rudderstack Initialization + Onetrust Integration + Rudderstack Custom Events -->
    <script type="text/javascript" src="https://www.databricks.com/sites/default/files/rudderstack/v1/db-rudderstack-events.js"></script>

  <!-- cookie consent -->

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="X-UA-Compatible" content="IE=9" />
  <meta content="Learn the recommended Databricks MLOps workflow to optimize performance and efficiency of your machine learning production systems." name="description" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
  <meta property="og:image" content="https://www.databricks.com/wp-content/uploads/2020/04/og-databricks.png">
  <meta property="og:image:type" content="image/png">
  <meta property="og:title" content="MLOps workflows on Databricks">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://docs.databricks.com">
  <meta property="og:description" content="" id="og-description">
  <meta name="twitter:image" content="https://www.databricks.com/wp-content/uploads/2020/04/og-databricks.png">
  <meta name="twitter:site" content="@databricks">
  <meta name="twitter:creator" content="@databricks">
  <meta property="twitter:description" content="">
  
  <title>MLOps workflows on Databricks &#124; Databricks on AWS</title>
  
  
  <link rel="canonical" href="https://docs.databricks.com/en/machine-learning/mlops/mlops-workflow.html">
  <!-- Start hreflang tag -->
  <link rel="alternate" hreflang="en" href="https://docs.databricks.com/en/machine-learning/mlops/mlops-workflow.html" />
<link rel="alternate" hreflang="x-default" href="https://docs.databricks.com/en/machine-learning/mlops/mlops-workflow.html" />
  <!-- End hreflang tag -->
  
  
  <link rel="shortcut icon" href="../../_static/favicon.ico" />
  

  

  

  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;
j.setAttributeNode(d.createAttribute('data-ot-ignore'));
f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-T85FQ33');</script>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;
j.setAttributeNode(d.createAttribute('data-ot-ignore'));
f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-TWTKQQ');</script>
    
  <!-- End Google Tag Manager -->


  <!-- MaxMind / GEO IP -->
  <script src="//js.maxmind.com/js/apis/geoip2/v2.1/geoip2.js" type="text/javascript"></script>
  <!-- End MaxMind / GEO IP -->

  
  
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600&display=swap" rel="stylesheet">
  <link rel="preload" href="../../_static/fonts/DMSans-Bold.ttf" as="font">
  <link rel="preload" href="../../_static/fonts/DMSans-Regular.ttf" as="font">
  <link rel="preload" href="../../_static/fonts/DMMono-Regular.ttf" as="font">
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/cloud-provider-selector.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/translation-selector.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/searchunify/main.css" type="text/css" />

  
  <link rel="index" title="Index" href="../../genindex.html" />
  <link rel="search" title="Search" href="../../search.html" />
  <link rel="top" title="Databricks on AWS" href="../../index.html" /> 
</head>

<body class="wy-body-for-nav" role="document">

  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T85FQ33"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TWTKQQ"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  
  <nav class="wy-nav-top header su_header" role="navigation" aria-label="top navigation">
    
<nav class="wy-nav-top header su_header" role="navigation" aria-label="top navigation">
  <div class="container-logo">
    <ul class="mobile-menu-toggle">
        <li class="menu-toggle">
            <i data-toggle="wy-nav-top" class="wy-nav-top-menu-button db-icon db-icon-menu pull-left"></i>
            
            <a href="https://www.databricks.com/" class="wy-nav-top-logo"><img src="../../_static/small-scale-lockup-full-color-rgb.svg" width="137" height="21"
              alt="Databricks" /></a>   
               
              </li>
    </ul>
    <ul class="su_nav-menu">
      <li class="menu-toggle">
        <i data-toggle="wy-nav-top" class="wy-nav-top-menu-button db-icon db-icon-menu pull-left"></i>
        
          
        
        <a href="https://www.databricks.com/" class="wy-nav-top-logo"><img src="../../_static/small-scale-lockup-full-color-rgb.svg" width="137" height="21"
            alt="Databricks" /></a></li>
        <!-- 
<li><a href="https://help.databricks.com/s/">Help Center</a></li>
<li class="active"><a href="https://docs.databricks.com/en/">Documentation</a></li>
<li><a href="https://kb.databricks.com/">Knowledge Base</a></li>
 -->
    </ul>
  </div>
  <div class="su_nav-right">
    <ul class="su_link-mobile">
  <!-- Mobile header code can go here -->
</ul>
<ul class="right-try-list">
   
</ul>
  </div>
</nav>
  </nav>

  <div class="su_sub-header">
    <div class="container">
      <div class="su_sub-header-inner">
        <!-- <div class="su_subnav-menu-right">
  <div id="auto" style="width: 100%;">
    <div ng-controller="SearchautoController">
      <div bind-html-compile="autocompleteHtml">
        <form class="su__search-box-1" disabled="disabled">
          <input class="su__search-input" type="search" name="Search box" id="su__search-b" placeholder="Search Documentation" disabled="disabled"/>
          <button class="su__search-button" type="submit" class="button button-success" disabled="disabled">
            <svg width="24" height="24" viewBox="0 0 24 24">
              <path
                d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
                fill="#333"></path>
            </svg>
          </button>
        </form>
      </div>
    </div>
  </div>
</div> -->
        <div class="search-lng-gap"></div>
        <div style="margin-left: 16px; margin-right: 16px;">
          <!-- <select name="lng selector" id="lng-selector">
    <option value="../../../en/machine-learning/mlops/mlops-workflow.html" class="notranslate">English</option>
    <option value="../../../ja/machine-learning/mlops/mlops-workflow.html" class="notranslate">日本語</option>
    <option value="../../../pt/machine-learning/mlops/mlops-workflow.html" class="notranslate">Português (Brasil)</option>
</select> -->
        </div>
        <div class="cloud-selector-container">
          <!-- <select name="cloud provider selector" id="cloud-provider-selector">
    <option value="aws" selected class="notranslate">
        Amazon Web Services
    </option>
    <option value="azure"  class="notranslate">
        Microsoft Azure
    </option>
    <option value="gcp"  class="notranslate">
        Google Cloud Platform
    </option>
</select> -->
        </div>
      </div>
    </div>
  </div>
  <page class="js-page-container">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side su_nav-side">
<div class="wy-side-scroll">
  <div class="wy-side-nav-search">
    

    

    

    
  </div>

  <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
    
      <a href="../../index.html" class="main-navigation-home">Databricks on AWS</a>
    

    
      

      
        <p class="caption"><span class="caption-text">Load &amp; manage data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../rag-temp/index.html">RAG Studio</a></li>
</ul>

      
    
  </div>

  <div role="contentinfo">
    
  <p class="build_info notranslate"data-last-edit="December 23, 2023">
    Updated Jan 11, 2024
  </p>
<script>
  window.addEventListener('DOMContentLoaded',function(){
    var h1=document.querySelector('h1');
    var bi=document.querySelector('[data-last-edit]');
    if(h1 && bi){
      var ver = document.createElement('p');
      ver.className = 'version_info';
      ver.textContent = bi.getAttribute('data-last-edit');
      h1.parentElement.insertBefore(ver, h1.nextElementSibling);
    }
  });
</script>

    <p>
      
        <a id='feedbacklink' href="mailto:doc-feedback@databricks.com?subject=Documentation Feedback">Send us feedback</a>
      
    </p>
  </div>
</div>
</nav>
    
    
<main class="wy-grid-for-nav su_nav-grid">
  <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
    <div class="wy-nav-content su__nav_content">
      <div class="rst-content">
        





<div role="navigation" aria-label="breadcrumbs navigation" class="wy-breadcrumbs-wrapper">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Documentation</a> <span class="db-icon db-icon-chevron-right"></span></li>
    
    
      <li>MLOps workflows on Databricks</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>
</div>
        
        <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
          <div itemprop="articleBody">
            
    
  <div class="section" id="mlops-workflows-on-databricks">
<h1>MLOps workflows on Databricks<a class="headerlink" href="#mlops-workflows-on-databricks" title="Permalink to this headline"> </a></h1>
<p>This article describes how you can use MLOps on the Databricks platform to optimize the performance and long-term efficiency of your machine learning (ML) systems. It includes general recommendations for an MLOps architecture and describes a generalized workflow using the Databricks platform that you can use as a model for your ML development-to-production process.</p>
<p>For more details, see <a class="reference external" href="https://www.databricks.com/resources/ebook/the-big-book-of-mlops">The Big Book of MLOps</a>.</p>
<div class="section" id="what-is-mlops">
<h2>What is MLOps?<a class="headerlink" href="#what-is-mlops" title="Permalink to this headline"> </a></h2>
<p>MLOps is a set of processes and automated steps to manage code, data, and models. It combines DevOps, DataOps, and ModelOps.</p>
<div class="figure align-default">
<img alt="MLOps lakehouse" src="../../_images/mlops-lakehouse.png" />
</div>
<p>ML assets such as code, data, and models are developed in stages that progress from early development stages that do not have tight access limitations and are not rigorously tested, through an intermediate testing stage, to a final production stage that is tightly controlled. The Databricks platform lets you manage these assets on a single platform with unified access control. You can develop data applications and ML applications on the same platform, reducing the risks and delays associated with moving data around.</p>
</div>
<div class="section" id="general-recommendations-for-mlops">
<h2>General recommendations for MLOps<a class="headerlink" href="#general-recommendations-for-mlops" title="Permalink to this headline"> </a></h2>
<p>This section includes some general recommendations for MLOps on Databricks with links for more information.</p>
<div class="section" id="create-a-separate-environment-for-each-stage">
<h3>Create a separate environment for each stage<a class="headerlink" href="#create-a-separate-environment-for-each-stage" title="Permalink to this headline"> </a></h3>
<p>An execution environment is the place where models and data are created or consumed by code. Each execution environment consists of compute instances, their runtimes and libraries, and automated jobs.</p>
<p>Databricks recommends creating separate environments for the different stages of ML code and model development with clearly defined transitions between stages. The workflow described in this article follows this process, using the common names for the stages:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#development-stage"><span class="std std-ref">Development</span></a></p></li>
<li><p><a class="reference internal" href="#staging-stage"><span class="std std-ref">Staging</span></a></p></li>
<li><p><a class="reference internal" href="#production-stage"><span class="std std-ref">Production</span></a></p></li>
</ul>
<p>Other configurations can also be used to meet the specific needs of your organization.</p>
</div>
<div class="section" id="access-control-and-versioning">
<h3>Access control and versioning<a class="headerlink" href="#access-control-and-versioning" title="Permalink to this headline"> </a></h3>
<p>Access control and versioning are key components of any software operations process. Databricks recommends the following:</p>
<ul class="simple">
<li><p><strong>Use Git for version control.</strong> Pipelines and code should be stored in Git for version control. Moving ML logic between stages can then be interpreted as moving code from the development branch, to the staging branch, to the release branch. Use <a class="reference internal" href="../../repos/index.html"><span class="doc">Databricks Repos</span></a> to integrate with your Git provider and sync notebooks and source code with Databricks workspaces. Databricks also provides additional tools for Git integration and version control; see <a class="reference internal" href="../../dev-tools/index.html"><span class="doc">Developer tools and guidance</span></a>.</p></li>
<li><p><strong>Store data in a lakehouse architecture using Delta tables.</strong> Data should be stored in a <a class="reference internal" href="../../lakehouse/index.html"><span class="doc">lakehouse architecture</span></a> in your cloud account. Both raw data and feature tables should be stored as <a class="reference internal" href="../../delta/index.html"><span class="doc">Delta tables</span></a> with access controls to determine who can read and modify them.</p></li>
<li><p><strong>Manage model development with MLflow.</strong> You can use <a class="reference internal" href="../../mlflow/index.html"><span class="doc">MLflow</span></a> to track the model development process and save code snapshots, model parameters, metrics, and other metadata.</p></li>
<li><p><strong>Use Models in Unity Catalog to manage the model lifecycle.</strong> Use <a class="reference internal" href="../../mlflow/models-in-uc.html"><span class="doc">Models in Unity Catalog</span></a> to manage model versioning, governance, and deployment status.</p></li>
</ul>
</div>
<div class="section" id="deploy-code-not-models">
<h3>Deploy code, not models<a class="headerlink" href="#deploy-code-not-models" title="Permalink to this headline"> </a></h3>
<p>In most situations, Databricks recommends that during the ML development process, you promote <em>code</em>, rather than  <em>models</em>, from one environment to the next. Moving project assets this way ensures that all code in the ML development process goes through the same code review and integration testing processes. It also ensures that the production version of the model is trained on production code. For a more detailed discussion of the options and trade-offs, see <a class="reference internal" href="deployment-patterns.html"><span class="doc">Model deployment patterns</span></a>.</p>
</div>
</div>
<div class="section" id="recommended-mlops-workflow">
<h2>Recommended MLOps workflow<a class="headerlink" href="#recommended-mlops-workflow" title="Permalink to this headline"> </a></h2>
<p>The following sections describe a typical MLOps workflow, covering each of the three stages: development, staging, and production.</p>
<p>This section uses the terms “data scientist” and “ML engineer” as archetypal personas; specific roles and responsibilities in the MLOps workflow will vary between teams and organizations.</p>
</div>
<div class="section" id="development-stage">
<h2>Development stage<a class="headerlink" href="#development-stage" title="Permalink to this headline"> </a></h2>
<p>The focus of the development stage is experimentation. Data scientists develop features and models and run experiments to optimize model performance. The output of the development process is ML pipeline code that can include feature computation, model training, inference, and monitoring.</p>
<div class="figure align-default">
<img alt="MLOps development stage diagram" src="../../_images/mlops-dev-diagram.png" />
</div>
<p>The numbered steps correspond to the numbers shown in the diagram.</p>
<div class="section" id="1-data-sources">
<h3>1. Data sources<a class="headerlink" href="#1-data-sources" title="Permalink to this headline"> </a></h3>
<p>The development environment is represented by the dev catalog in Unity Catalog. Data scientists have read-write access to the dev catalog as they create temporary data and feature tables in the development workspace. Models created in the development stage are registered to the dev catalog.</p>
<p>Ideally, data scientists working in the development workspace also have read-only access to production data in the prod catalog. Allowing data scientists read access to production data, inference tables, and metric tables in the prod catalog enables them to analyze current production model predictions and performance. Data scientists should also be able to load production models for experimentation and analysis.</p>
<p>If it is not possible to grant read-only access to the prod catalog, a snapshot of production data can be written to the dev catalog to enable data scientists to develop and evaluate project code.</p>
</div>
<div class="section" id="2-exploratory-data-analysis-eda">
<h3>2. Exploratory data analysis (EDA)<a class="headerlink" href="#2-exploratory-data-analysis-eda" title="Permalink to this headline"> </a></h3>
<p>Data scientists explore and analyze data in an interactive, iterative process using notebooks. The goal is to assess whether the available data has the potential to solve the business problem. In this step, the data scientist begins identifying data preparation and featurization steps for model training. This ad hoc process is generally not part of a pipeline that will be deployed in other execution environments.</p>
<p><a class="reference internal" href="../automl/index.html"><span class="doc">Databricks AutoML</span></a> accelerates this process by generating baseline models for a dataset. AutoML performs and records a set of trials and provides a Python notebook with the source code for each trial run, so you can review, reproduce, and modify the code. AutoML also calculates summary statistics on your dataset and saves this information in a notebook that you can review.</p>
</div>
<div class="section" id="3-code">
<h3>3. Code<a class="headerlink" href="#3-code" title="Permalink to this headline"> </a></h3>
<p>The code repository contains all of the pipelines, modules, and other project files for an ML project. Data scientists create new or updated pipelines in a development (“dev”) branch of the project repository. Starting from EDA and the initial phases of a project, data scientists should work in a repository to share code and track changes.</p>
</div>
<div class="section" id="4-train-model-development">
<h3>4. Train model (development)<a class="headerlink" href="#4-train-model-development" title="Permalink to this headline"> </a></h3>
<p>Data scientists develop the model training pipeline in the development environment using tables from the dev or prod catalogs.</p>
<p>This pipeline includes 2 tasks:</p>
<ul>
<li><p><strong>Training and tuning.</strong> The training process logs model parameters, metrics, and artifacts to the MLflow Tracking server. After training and tuning hyperparameters, the final model artifact is logged to the tracking server to record a link between the model, the input data it was trained on, and the code used to generate it.</p></li>
<li><p><strong>Evaluation.</strong> Evaluate model quality by testing on held-out data. The results of these tests are logged to the MLflow Tracking server. The purpose of evaluation is to determine if the newly developed model performs better than the current production model. Given sufficient permissions, any production model registered to the prod catalog can be loaded into the development workspace and compared against a newly trained model.</p>
<p>If your organization’s governance requirements include additional information about the model, you can save it using <a class="reference internal" href="../../mlflow/tracking.html"><span class="doc">MLflow tracking</span></a>. Typical artifacts are plain text descriptions and model interpretations such as plots produced by SHAP. Specific governance requirements may come from a data governance officer or business stakeholders.</p>
</li>
</ul>
<p>The output of the model training pipeline is an ML model artifact stored in the MLflow Tracking server for the development environment. If the pipeline is executed in the staging or production workspace, the model artifact is stored in the MLflow Tracking server for that workspace.</p>
<p>When the model training is complete, register the model to Unity Catalog. Set up your pipeline code to register the model to the catalog corresponding to the environment that the model pipeline was executed in; in this example, the dev catalog.</p>
<p>With the recommended architecture, you deploy a multitask Databricks workflow in which the first task is the model training pipeline, followed by model validation and model deployment tasks. The model training task yields a model URI that the model validation task can use. You can use <a class="reference internal" href="../../workflows/jobs/share-task-context.html"><span class="doc">task values</span></a> to pass this URI to the model.</p>
</div>
<div class="section" id="5-validate-and-deploy-model-development">
<h3>5. Validate and deploy model (development)<a class="headerlink" href="#5-validate-and-deploy-model-development" title="Permalink to this headline"> </a></h3>
<p>In addition to the model training pipeline, other pipelines such as model validation and model deployment pipelines are developed in the development environment.</p>
<ul>
<li><p><strong>Model validation.</strong> The model validation pipeline takes the model URI from the model training pipeline, loads the model from Unity Catalog, and runs validation checks.</p>
<p>Validation checks depend on the context. They can include fundamental checks such as confirming format and required metadata, and more complex checks that might be required for highly regulated industries, such as predefined compliance checks and confirming model performance on selected data slices.</p>
<p>The primary function of the model validation pipeline is to determine whether a model should proceed to the deployment step. If the model passes pre-deployment checks, it can be assigned the “Challenger” alias in Unity Catalog. If the checks fail, the process ends. You can configure your workflow to notify users of a validation failure. See <a class="reference internal" href="../../workflows/jobs/job-notifications.html"><span class="doc">Add email and system notifications for job events</span></a>.</p>
</li>
<li><p><strong>Model deployment.</strong> The model deployment pipeline typically either directly promotes the newly trained “Challenger” model to “Champion” status using an alias update, or facilitates a comparison between the existing “Champion” model and the new “Challenger” model. This pipeline can also set up any required inference infrastructure, such as Model Serving endpoints. For a detailed discussion of the steps involved in the model deployment pipeline, see <a class="reference internal" href="#production-stage"><span class="std std-ref">Production</span></a>.</p></li>
</ul>
</div>
<div class="section" id="6-commit-code">
<h3>6. Commit code<a class="headerlink" href="#6-commit-code" title="Permalink to this headline"> </a></h3>
<p>After developing code for training, validation, deployment and other pipelines, the data scientist or ML engineer commits the dev branch changes into source control.</p>
</div>
</div>
<div class="section" id="staging-stage">
<h2>Staging stage<a class="headerlink" href="#staging-stage" title="Permalink to this headline"> </a></h2>
<p>The focus of this stage is testing the ML pipeline code to ensure it is ready for production. All of the ML pipeline code is tested in this stage, including code for model training as well as feature engineering pipelines, inference code, and so on.</p>
<p>ML engineers create a CI pipeline to implement the unit and integration tests run in this stage. The output of the staging process is a release branch that triggers the CI/CD system to start the production stage.</p>
<div class="figure align-default">
<img alt="MLOps staging stage diagram" src="../../_images/mlops-staging-diagram.png" />
</div>
<div class="section" id="1-data">
<h3>1. Data<a class="headerlink" href="#1-data" title="Permalink to this headline"> </a></h3>
<p>The staging environment should have its own catalog in Unity Catalog for testing ML pipelines and registering models to Unity Catalog. This catalog is shown as the “staging” catalog in the diagram. Assets written to this catalog are generally temporary and only retained until testing is complete. The development environment may also require access to the staging catalog for debugging purposes.</p>
</div>
<div class="section" id="2-merge-code">
<h3>2. Merge code<a class="headerlink" href="#2-merge-code" title="Permalink to this headline"> </a></h3>
<p>Data scientists develop the model training pipeline in the development environment using tables from the development or production catalogs.</p>
<ul>
<li><p><strong>Pull request.</strong> The deployment process begins when a pull request is created against the main branch of the project in source control.</p></li>
<li><p><strong>Unit tests (CI).</strong> The pull request automatically builds source code and triggers unit tests. If unit tests fail, the pull request is rejected.</p>
<p>Unit tests are part of the software development process and are continuously executed and added to the codebase during the development of any code. Running unit tests as part of a CI pipeline ensures that changes made in a development branch do not break existing functionality.</p>
</li>
</ul>
</div>
<div class="section" id="3-integration-tests-ci">
<h3>3. Integration tests (CI)<a class="headerlink" href="#3-integration-tests-ci" title="Permalink to this headline"> </a></h3>
<p>The CI process then runs the integration tests. Integration tests run all pipelines (including feature engineering, model training, inference, and monitoring) to ensure that they function correctly together. The staging environment should match the production environment as closely as is reasonable.</p>
<p>If you are deploying an ML application with real-time inference, you should create and test serving infrastructure in the staging environment. This involves triggering the model deployment pipeline, which creates a serving endpoint in the staging environment and loads a model.</p>
<p>To reduce the time required to run integration tests, some steps can trade off between fidelity of testing and speed or cost. For example, if models are expensive or time-consuming to train, you might use small subsets of data or run fewer training iterations. For model serving, depending on production requirements, you might do full-scale load testing in integration tests, or you might just test small batch jobs or requests to a temporary endpoint.</p>
</div>
<div class="section" id="4-merge-to-staging-branch">
<h3>4. Merge to staging branch<a class="headerlink" href="#4-merge-to-staging-branch" title="Permalink to this headline"> </a></h3>
<p>If all tests pass, the new code is merged into the main branch of the project. If tests fail, the CI/CD system should notify users and post results on the pull request.</p>
<p>You can schedule periodic integration tests on the main branch. This is a good idea if the branch is updated frequently with concurrent pull requests from multiple users.</p>
</div>
<div class="section" id="5-create-a-release-branch">
<h3>5. Create a release branch<a class="headerlink" href="#5-create-a-release-branch" title="Permalink to this headline"> </a></h3>
<p>After CI tests have passed and the dev branch is merged into the main branch, the ML engineer creates a release branch, which triggers the CI/CD system to update production jobs.</p>
</div>
</div>
<div class="section" id="production-stage">
<h2>Production stage<a class="headerlink" href="#production-stage" title="Permalink to this headline"> </a></h2>
<p>ML engineers own the production environment where ML pipelines are deployed and executed. These pipelines trigger model training, validate and deploy new model versions, publish predictions to downstream tables or applications, and monitor the entire process to avoid performance degradation and instability.</p>
<p>Data scientists typically do not have write or compute access in the production environment. However, it is important that they have visibility to test results, logs, model artifacts, production pipeline status, and monitoring tables. This visibility allows them to identify and diagnose problems in production and to compare the performance of new models to models currently in production. You can grant data scientists read-only access to assets in the production catalog for these purposes.</p>
<div class="figure align-default">
<img alt="MLOps production stage diagram" src="../../_images/mlops-prod-diagram.png" />
</div>
<p>The numbered steps correspond to the numbers shown in the diagram.</p>
<div class="section" id="1-train-model">
<h3>1. Train model<a class="headerlink" href="#1-train-model" title="Permalink to this headline"> </a></h3>
<p>This pipeline can be triggered by code changes or by automated retraining jobs. In this step, tables from the production catalog are used for the following steps.</p>
<ul>
<li><p><strong>Training and tuning.</strong> During the training process, logs are recorded to the production environment MLflow Tracking server. These logs include model metrics, parameters, tags, and the model itself. If you use feature tables, the model is logged to MLflow using the Databricks Feature Store client, which packages the model with feature lookup information that is used at inference time.</p>
<p>During development, data scientists may test many algorithms and hyperparameters. In the production training code, it’s common to consider only the top-performing options. Limiting tuning in this way saves time and can reduce the variance from tuning in automated retraining.</p>
<p>If data scientists have read-only access to the production catalog, they may be able to determine the optimal set of hyperparameters for a model. In this case, the model training pipeline deployed in production can be executed using the selected set of hyperparameters, typically included in the pipeline as a configuration file.</p>
</li>
<li><p><strong>Evaluation.</strong> Model quality is evaluated by testing on held-out production data.  The results of these tests are logged to the MLflow tracking server. This step uses the evaluation metrics specified by data scientists in the development stage. These metrics may include custom code.</p></li>
<li><p><strong>Register model.</strong> When model training is complete, the model artifact is saved as a registered model version at the specified model path in the production catalog in Unity Catalog. The model training task yields a model URI that the model validation task can use. You can use <a class="reference internal" href="../../workflows/jobs/share-task-context.html"><span class="doc">task values</span></a> to pass this URI to the model.</p></li>
</ul>
</div>
<div class="section" id="2-validate-model">
<h3>2. Validate model<a class="headerlink" href="#2-validate-model" title="Permalink to this headline"> </a></h3>
<p>This pipeline uses the model URI from Step 1 and loads the model from Unity Catalog. It then executes a series of validation checks. These checks depend on your organization and use case, and can include things like basic format and metadata validations, performance evaluations on selected data slices, and compliance with organizational requirements such as compliance checks for tags or documentation.</p>
<p>If the model successfully passes all validation checks, you can assign the “Challenger” alias to the model version in Unity Catalog. If the model does not pass all validation checks, the process exits and users can be automatically notified. You can use tags to add key-value attributes depending on the outcome of these validation checks. For example, you could create a tag “model_validation_status” and set the value to “PENDING” as the tests execute, and then update it to “PASSED” or “FAILED” when the pipeline is complete.</p>
<p>Because the model is registered to Unity Catalog, data scientists working in the development environment can load this model version from the production catalog to investigate if the model fails validation. Regardless of the outcome, results are recorded to the registered model in the production catalog using annotations to the model version.</p>
</div>
<div class="section" id="3-deploy-model">
<h3>3. Deploy model<a class="headerlink" href="#3-deploy-model" title="Permalink to this headline"> </a></h3>
<p>Like the validation pipeline, the model deployment pipeline depends on your organization and use case. This section assumes that you have assigned the newly validated model the “Challenger” alias, and that the existing production model has been assigned the “Champion” alias. The first step before deploying the new model is to confirm that it performs at least as well as the current production model.</p>
<ul>
<li><p><strong>Compare “CHALLENGER” to “CHAMPION” model.</strong> You can perform this comparison offline or online. An offline comparison evaluates both models against a held-out data set and tracks results using the MLflow Tracking server. For real-time model serving, you might want to perform longer running online comparisons, such as A/B tests or a gradual rollout of the new model. If the “Challenger” model version performs better in the comparison, it replaces the current “Champion” alias.</p>
<p>Databricks Model Serving and Databricks Lakehouse Monitoring allow you to automatically collect and monitor inference tables that contain request and response data for an endpoint.</p>
<p>If there is no existing “Champion” model, you might compare the “Challenger” model to a business heuristic or other threshold as a baseline.</p>
<p>The process described here is fully automated. If manual approval steps are required, you can set those up using workflow notifications or CI/CD callbacks from the model deployment pipeline.</p>
</li>
<li><p><strong>Deploy model.</strong> Batch or streaming inference pipelines can be set up to use the model with the “Champion” alias. For real-time use cases, you must set up the infrastructure to deploy the model as a REST API endpoint. You can create and manage this endpoint using Databricks Model Serving. If an endpoint is already in use for the current model, you can update the endpoint with the new model. Databricks Model Serving executes a zero-downtime update by keeping the existing configuration running until the new one is ready.</p></li>
</ul>
</div>
<div class="section" id="4-model-serving">
<h3>4. Model Serving<a class="headerlink" href="#4-model-serving" title="Permalink to this headline"> </a></h3>
<p>When configuring a Model Serving endpoint, you specify the name of the model in Unity Catalog and the version to serve. If the model version was trained using features from tables in Unity Catalog, the model stores the dependencies for the features and functions. Model Serving automatically uses this dependency graph to look up features from appropriate online stores at inference time. This approach can also be used to apply functions for data preprocessing or to compute on-demand features during model scoring.</p>
<p>You can create a single endpoint with multiple models and specify the endpoint traffic split between those models, allowing you to conduct online “Champion” versus “Challenger” comparisons.</p>
</div>
<div class="section" id="5-inference-batch-or-streaming">
<h3>5. Inference: batch or streaming<a class="headerlink" href="#5-inference-batch-or-streaming" title="Permalink to this headline"> </a></h3>
<p>The inference pipeline reads the latest data from the production catalog, executes functions to compute on-demand features, loads the “Champion” model, scores the data, and returns predictions. Batch or streaming inference is generally the most cost-effective option for higher throughput, higher latency use cases. For scenarios where low-latency predictions are required, but predictions can be computed offline, these batch predictions can be published to an online key-value store such as DynamoDB or Cosmos DB.</p>
<p>The registered model in Unity Catalog is referenced by its alias. The inference pipeline is configured to load and apply the “Champion” model version. If the “Champion” version is updated to a new model version, the inference pipeline automatically uses the new version for its next execution. In this way the model deployment step is decoupled from inference pipelines.</p>
<p>Batch jobs typically publish predictions to tables in the production catalog, to flat files, or over a JDBC connection. Streaming jobs typically publish predictions either to Unity Catalog tables or to message queues like Apache Kafka.</p>
</div>
<div class="section" id="6-lakehouse-monitoring">
<h3>6. Lakehouse Monitoring<a class="headerlink" href="#6-lakehouse-monitoring" title="Permalink to this headline"> </a></h3>
<p>Lakehouse Monitoring monitors statistical properties, such as data drift and model performance, of input data and model predictions. You can create alerts based on these metrics or publish them in dashboards.</p>
<ul class="simple">
<li><p><strong>Data ingestion.</strong> This pipeline reads in logs from batch, streaming, or online inference.</p></li>
<li><p><strong>Check accuracy and data drift.</strong> The pipeline computes metrics about the input data, the model’s predictions, and the infrastructure performance. Data scientists specify data and model metrics during development, and ML engineers specify infrastructure metrics. You can also define custom metrics with Lakehouse Monitoring.</p></li>
<li><p><strong>Publish metrics and set up alerts.</strong> The pipeline writes to tables in the production catalog for analysis and reporting. You should configure these tables to be readable from the development environment so data scientists have access for analysis. You can use Databricks SQL to create monitoring dashboards to track model performance, and set up the monitoring job or the dashboard tool to issue a notification when a metric exceeds a specified threshold.</p></li>
<li><p><strong>Trigger model retraining.</strong> When monitoring metrics indicate performance issues or changes in the input data, the data scientist may need to develop a new model version. You can set up SQL alerts to notify data scientists when this happens.</p></li>
</ul>
</div>
<div class="section" id="7-retraining">
<h3>7. Retraining<a class="headerlink" href="#7-retraining" title="Permalink to this headline"> </a></h3>
<p>This architecture supports automatic retraining using the same model training pipeline above. Databricks recommends beginning with scheduled, periodic retraining and moving to triggered retraining when needed.</p>
<ul class="simple">
<li><p><strong>Scheduled.</strong> If new data is available on a regular basis, you can create a <a class="reference internal" href="../../workflows/jobs/create-run-jobs.html"><span class="doc">scheduled job</span></a> to run the model training code on the latest available data.</p></li>
<li><p><strong>Triggered.</strong> If the monitoring pipeline can identify model performance issues and send alerts, it can also trigger retraining. For example, if the distribution of incoming data changes significantly or if the model performance degrades, automatic retraining and redeployment can boost model performance with minimal human intervention. This can be achieved through a SQL alert to check whether a metric is anomalous (for example, check drift or model quality against a threshold). The alert can be configured to use a webhook destination, which can subsequently trigger the training workflow.</p></li>
</ul>
<p>If the retraining pipeline or other pipelines exhibit performance issues, the data scientist may need to return to the development environment for additional experimentation to address the issues.</p>
<div class="toctree-wrapper compound">
</div>
</div>
</div>
</div>


    
          </div>
        </div>
        <div  class="suapp-rating">
  <div id="suPageRateApp">
     <su-app></su-app>
   </div> 
 </div>
<hr> 
<footer>
  <div role="contentinfo">
      <p class="copyright">
          &copy; Databricks 2023. All rights reserved. Apache, Apache Spark, Spark, and the Spark logo are trademarks of the <a href="http://www.apache.org/">Apache Software Foundation</a>.
      </p>
      <p> 
        
          <a id='feedbacklink' href="mailto:doc-feedback@databricks.com?subject=Documentation Feedback">Send us feedback</a>
        
     | <a href="https://databricks.com/privacy-policy">Privacy Policy</a> | <a href="https://databricks.com/terms-of-use">Terms of Use</a></p>

  </div> 

</footer>
      </div>
    </div>
  </section>
</main>

  </page>
  
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT: '../../',
      VERSION: '1.0',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE: 'false'
    };
  </script>
  <script type="text/javascript" src="../../_static/jquery.js"></script>
  <script type="text/javascript" src="../../_static/underscore.js"></script>
  <script type="text/javascript" src="../../_static/doctools.js"></script>
  <script type="text/javascript" src="../../_static/language_data.js"></script>
  

  <script type="text/javascript" src="../../_static/js/clipboard.min.js"></script>
  <script type="text/javascript" src="../../_static/js/jquery.waypoints.min.js"></script>

  <!-- Select2 (https://select2.org/) -->
  <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
  <!-- End Select2 -->

  
  
  <script type="text/javascript" src="../../_static/js/localized.js"></script>
  <script type="text/javascript" src="../../_static/js/custom.js"></script>
  

  
  
  <script type="text/javascript">
    jQuery(function () {
      SphinxRtdTheme.StickyNav.enable();
    });

  </script>
  
 



  <script>
  window.__searchunifyLoaderConfig = JSON.parse('{"clients": {"en": "02c2e804-27e9-11ee-aefb-0242ac120011", "ja": "6a42c3f2-2820-11ee-aefb-0242ac120011", "pt": "6a86badd-2821-11ee-aefb-0242ac120011"}}')
</script>
<script type="text/javascript" src="../../_static/js/search-loader.js"></script>
</body>
<script type='text/javascript'>
  window.onload = function () {
    var description = document.querySelector('meta[name="description"]').getAttribute("content");
    let titleText = document.querySelector('h1').textContent;
    document.querySelector('meta[property="og:title"]').setAttribute("content", titleText);
    document.querySelector('meta[property="og:description"]').setAttribute("content", description);
    document.querySelector('meta[property="twitter:description"]').setAttribute("content", description);
  };
</script>

</html>